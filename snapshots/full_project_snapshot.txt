Project Structure:
+-- CHANGELOG.md
+-- README.md
+-- config
|   +-- webpack.config.md
+-- cypress
|   +-- integration
|       +-- create_deck.spec.js
+-- cypress.json
+-- docs
|   +-- ui_specs.md
+-- package-lock.json
+-- package.json
+-- public
|   +-- index.html
|   +-- manifest.json
|   +-- robots.txt
+-- run_sc.sh
+-- scripts
|   +-- create_bdd.sh
|   +-- create_files.sh
|   +-- gen_proj.sh
|   +-- generate_snapshot.sh
+-- specs
|   +-- card_editor
|   |   +-- create_card.feature
|   |   +-- delete_card.feature
|   |   +-- edit_card.feature
|   +-- deck_management
|       +-- add_card_to_deck.feature
|       +-- create_deck.feature
|       +-- delete_deck.feature
|       +-- edit_deck.feature
|       +-- export_deck.feature
|       +-- remove_card_from_deck.feature
+-- src
|   +-- App.css
|   +-- App.md
|   +-- App.tsx
|   +-- __tests__
|   |   +-- App.test.tsx
|   |   +-- components
|   +-- components
|   |   +-- cards
|   |   +-- common
|   |   +-- decks
|   |   +-- layout
|   +-- constants
|   |   +-- appConstants.md
|   +-- context
|   |   +-- AppStateContext.md
|   |   +-- AppStateContext.tsx
|   |   +-- ThemeContext.md
|   +-- hooks
|   |   +-- useCanvas.md
|   |   +-- useCanvas.ts
|   |   +-- useDeck.md
|   |   +-- useElement.ts
|   +-- index.md
|   +-- index.tsx
|   +-- pages
|   |   +-- DeckManagement.md
|   |   +-- DeckManagement.tsx
|   |   +-- Editor.md
|   |   +-- Editor.tsx
|   |   +-- Home.md
|   |   +-- Home.tsx
|   |   +-- __tests__
|   +-- react-app-env.d.ts
|   +-- services
|   |   +-- api.md
|   |   +-- storage.md
|   |   +-- storage.ts
|   +-- setupTest.js
|   +-- styles
|   |   +-- globalStyles.md
|   |   +-- globalStyles.ts
|   |   +-- theme.md
|   +-- types
|   |   +-- Card.md
|   |   +-- Card.ts
|   |   +-- Deck.md
|   |   +-- Deck.ts
|   |   +-- Shape.md
|   |   +-- Shape.ts
|   +-- utils
|       +-- colorUtils.md
|       +-- shapes.md
|       +-- validators.md
+-- tests
|   +-- e2e
|   |   +-- *
|   +-- integration
|   |   +-- *
|   +-- unit
|       +-- components
|       +-- hooks
|       +-- utils
+-- tsconfig.json

File Contents:

File: ./cypress/integration/create_deck.spec.js
----------------------------------------
describe('Create Deck', () => {
  it('successfully creates a new deck', () => {
    cy.visit('/deck-management');
    cy.get('input[placeholder="Enter deck name"]').type('New Test Deck');
    cy.get('input[placeholder="Enter deck description"]').type('This is a test deck');
    cy.contains('Create New Deck').click();
    cy.contains('New Test Deck').should('be.visible');
    cy.contains('This is a test deck').should('be.visible');
  });
});
----------------------------------------

File: ./CHANGELOG.md
----------------------------------------
----------------------------------------

File: ./config/webpack.config.md
----------------------------------------
# webpack.config

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./specs/deck_management/export_deck.feature
----------------------------------------
Feature: Export deck to JSON
  As a user
  I want to export my deck to a JSON file
  So that I can backup my work or share it with others

  Background:
    Given I am on the deck management page
    And I have a deck named "Physics" with 15 existing cards

  Scenario: Successfully export deck to JSON
    When I select the "Physics" deck
    And I click the "Export to JSON" button
    Then a JSON file should be downloaded
    And the file should be named "Physics_deck.json"
    And the JSON file should contain all 15 cards with their content

  Scenario: Export deck with complex elements
    Given I have a deck with cards containing text and shapes
    When I export the deck to JSON
    Then the JSON file should include all elements of each card
    And the positioning and styling of elements should be preserved

  Scenario: Validate exported JSON
    When I export a deck to JSON
    And I import the JSON file back into the application
    Then all cards should be recreated exactly as they were before export

  Scenario: Export empty deck
    Given I have an empty deck named "New Deck"
    When I select the "New Deck"
    And I click the "Export to JSON" button
    Then a JSON file named "New_Deck.json" should be downloaded
    And the JSON file should contain an empty array of cards----------------------------------------

File: ./specs/deck_management/remove_card_from_deck.feature
----------------------------------------
Feature: uremove card from deck

  As a user
  I want to remove card from deck
  So that I can effectively manage my flash cards

  Scenario: Successful remove card from deck
    Given I am on the deck management page
    When I perform the necessary actions to remove card from deck
    Then I should see the expected result

  Scenario: Unsuccessful remove card from deck
    Given I am on the deck management page
    When I perform invalid actions
    Then I should see an appropriate error message
----------------------------------------

File: ./specs/deck_management/create_deck.feature
----------------------------------------
Feature: ucreate deck

  As a user
  I want to create deck
  So that I can effectively manage my flash cards

  Scenario: Successful create deck
    Given I am on the deck management page
    When I perform the necessary actions to create deck
    Then I should see the expected result

  Scenario: Unsuccessful create deck
    Given I am on the deck management page
    When I perform invalid actions
    Then I should see an appropriate error message
----------------------------------------

File: ./specs/deck_management/add_card_to_deck.feature
----------------------------------------
Feature: uadd card to deck

  As a user
  I want to add card to deck
  So that I can effectively manage my flash cards

  Scenario: Successful add card to deck
    Given I am on the deck management page
    When I perform the necessary actions to add card to deck
    Then I should see the expected result

  Scenario: Unsuccessful add card to deck
    Given I am on the deck management page
    When I perform invalid actions
    Then I should see an appropriate error message
----------------------------------------

File: ./specs/deck_management/delete_deck.feature
----------------------------------------
Feature: Delete a deck
  As a user
  I want to delete a deck
  So that I can remove unnecessary or outdated collections of cards

  Background:
    Given I am on the deck management page
    And I have at least one existing deck

  Scenario: Successfully delete a deck
    When I select a deck to delete
    And I click the "Delete Deck" button
    Then I should see a confirmation dialog
    When I confirm the deletion
    Then I should see a success message
    And the deck should no longer appear in my deck list

  Scenario: Cancel deck deletion
    When I select a deck to delete
    And I click the "Delete Deck" button
    Then I should see a confirmation dialog
    When I cancel the deletion
    Then the deck should still appear in my deck list

  Scenario: Delete a deck with cards
    Given I have a deck "Physics Formulas" with 10 cards
    When I delete the "Physics Formulas" deck
    Then I should see a warning message about deleting all associated cards
    When I confirm the deletion
    Then I should see a success message
    And the "Physics Formulas" deck and its cards should be removed from my account

  Scenario: Attempt to delete the last deck
    Given I have only one deck in my account
    When I try to delete the deck
    Then I should see a warning message
    And I should be asked to create a new deck before deleting the last one----------------------------------------

File: ./specs/deck_management/edit_deck.feature
----------------------------------------
Feature: Edit an existing deck
  As a user
  I want to edit an existing deck
  So that I can update its name, description, or organization

  Background:
    Given I am on the deck management page
    And I have an existing deck named "History Dates"

  Scenario: Edit deck name and description
    When I select the "History Dates" deck
    And I click "Edit Deck"
    And I change the name to "Important Historical Events"
    And I update the description to "Key dates and events in world history"
    And I click "Save Changes"
    Then I should see a success message
    And the deck should be updated with the new name and description

  Scenario: Add tags to an existing deck
    When I select the "History Dates" deck
    And I click "Edit Deck"
    And I add tags "history, dates, academic"
    And I click "Save Changes"
    Then I should see a success message
    And the deck should be updated with the new tags

  Scenario: Reorder cards within a deck
    Given the "History Dates" deck has at least 3 cards
    When I select the "History Dates" deck
    And I click "Edit Deck"
    And I drag the third card to the first position
    And I click "Save Changes"
    Then I should see a success message
    And the cards in the deck should be in the new order

  Scenario: Attempt to save a deck with an empty name
    When I select the "History Dates" deck
    And I click "Edit Deck"
    And I delete the deck name
    And I click "Save Changes"
    Then I should see an error message "Deck name cannot be empty"
    And the deck should not be updated----------------------------------------

File: ./specs/card_editor/delete_card.feature
----------------------------------------
Feature: Delete a flash card
  As a user
  I want to delete a flash card
  So that I can remove unnecessary or incorrect cards from my deck

  Background:
    Given I am on the card management page
    And I have at least one existing card

  Scenario: Successfully delete a card
    When I select a card to delete
    And I click the "Delete" button
    Then I should see a confirmation dialog
    When I confirm the deletion
    Then I should see a success message
    And the card should no longer appear in my card list

  Scenario: Cancel card deletion
    When I select a card to delete
    And I click the "Delete" button
    Then I should see a confirmation dialog
    When I cancel the deletion
    Then the card should still appear in my card list

  Scenario: Delete the last card in a deck
    Given I have only one card in my deck
    When I delete the card
    Then I should see a success message
    And I should see an empty deck message
    And I should see an option to create a new card

  Scenario: Attempt to delete a card that is part of a study session
    Given I have an active study session
    When I try to delete a card that is part of the session
    Then I should see a warning message
    And I should be asked to end the study session before deleting the card----------------------------------------

File: ./specs/card_editor/edit_card.feature
----------------------------------------
Feature: Edit an existing flash card
  As a user
  I want to edit an existing flash card
  So that I can update or correct its content

  Background:
    Given I am on the card editor page
    And I have an existing card with content

  Scenario: Edit text on an existing card
    When I select the existing card
    And I modify the text on Side A to "Updated question"
    And I modify the text on Side B to "Updated answer"
    And I click "Save Changes"
    Then I should see a success message
    And the card should be updated with the new content

  Scenario: Add a shape to an existing card
    When I select the existing card
    And I add a triangle to Side A
    And I click "Save Changes"
    Then I should see a success message
    And the card should be updated with the new shape

  Scenario: Change colors on an existing card
    When I select the existing card
    And I change the background color of Side A to green
    And I change the text color of Side B to red
    And I click "Save Changes"
    Then I should see a success message
    And the card should be updated with the new colors

  Scenario: Attempt to save a card with empty content
    When I select the existing card
    And I delete all content from Side A
    And I click "Save Changes"
    Then I should see an error message "Card must have content on both sides"
    And the card should not be updated

  Scenario: Cancel editing a card
    When I select the existing card
    And I modify the text on Side A
    And I click "Cancel"
    Then I should see a confirmation dialog
    When I confirm the cancellation
    Then the card should not be updated
    And I should return to the card list view

  Background:
    Given I am on the card editor page
    And I am viewing the "Physics" deck with existing cards

  Scenario: Edit both sides of an existing card
    When I select "Card 1: Newton's First Law" from the card list
    Then I should see Side A and Side B of the card displayed side by side
    When I modify the text on Side A to "Updated question"
    And I modify the text on Side B to "Updated answer"
    And I click "Save"
    Then I should see a success message
    And the card should be updated with the new content on both sides

  Scenario: Add shapes to both sides of a card
    When I select an existing card from the list
    And I add a rectangle to Side A
    And I add a circle to Side B
    Then I should see the shapes on their respective sides simultaneously

  Scenario: Undo changes on one side
    When I select an existing card from the list
    And I make changes to Side A
    And I click the undo button for Side A
    Then only the changes on Side A should be undone
    And Side B should remain unchanged

    Feature: Edit an existing flash card

  Background:
    Given I am on the card editor page
    And I am viewing the "Physics" deck with existing cards

  Scenario: Edit both sides of an existing card
    When I select "Card 1: Newton's First Law" from the card list
    Then I should see Side A and Side B of the card displayed side by side
    When I modify the text on Side A to "Updated question"
    And I modify the text on Side B to "Updated answer"
    And I click "Save"
    Then I should see a success message
    And the card should be updated with the new content on both sides

  Scenario: Add shapes to both sides of a card
    When I select an existing card from the list
    And I add a rectangle to Side A
    And I add a circle to Side B
    Then I should see the shapes on their respective sides simultaneously

  Scenario: Undo changes on one side
    When I select an existing card from the list
    And I make changes to Side A
    And I click the undo button for Side A
    Then only the changes on Side A should be undone
    And Side B should remain unchanged----------------------------------------

File: ./specs/card_editor/create_card.feature
----------------------------------------
Feature: Create a new flash card
  As a user
  I want to create a new flash card
  So that I can add content to my study decks

  Background:
    Given I am on the card editor page

  Scenario: Successfully create a basic flash card
    When I click on "New Card"
    And I add text "What is the capital of France?" to Side A
    And I add text "Paris" to Side B
    And I click "Save Card"
    Then I should see a success message
    And the new card should appear in my card list

  Scenario: Create a card with shapes and text
    When I click on "New Card"
    And I add a rectangle to Side A
    And I add text "Shape:" inside the rectangle on Side A
    And I add a circle to Side B
    And I add text "Circle" inside the circle on Side B
    And I click "Save Card"
    Then I should see a success message
    And the new card should appear in my card list with shapes and text

  Scenario: Attempt to create an empty card
    When I click on "New Card"
    And I click "Save Card" without adding any content
    Then I should see an error message "Card must have content on both sides"

  Scenario: Create a card with custom colors
    When I click on "New Card"
    And I add text "Color question" to Side A
    And I change the text color to blue on Side A
    And I add text "Blue" to Side B
    And I change the background color to blue on Side B
    And I click "Save Card"
    Then I should see a success message
    And the new card should appear in my card list with custom colors

Background:
  Given I am on the card editor page
  And I am viewing the "Physics" deck with 15 existing cards

Scenario: Successfully create a new flash card
  When I click on "Create New Card"
  And I add text "What is the speed of light?" to Side A
  And I add text "299,792,458 meters per second" to Side B
  And I click "Save"
  Then I should see a success message
  And the card list should update to show 16 cards
  And the new card should appear at the bottom of the card list

Scenario: View newly created card in the list
  When I create a new card with the question "What is Newton's Second Law?"
  Then I should see the new card in the card list
  And the card count should increase by 1

Scenario: Edit both sides simultaneously
  When I create a new card
  Then I should be able to edit Side A and Side B simultaneously
  And changes on one side should not affect the other side

Scenario: View newly created card in the list
  When I create a new card with the question "What is Newton's Second Law?" on Side A
  And I add the answer "F = ma" on Side B
  Then I should see the new card in the card list
  And the card count should increase by 1


  Feature: Create a new flash card

  Background:
    Given I am on the card editor page
    And I am viewing the "Physics" deck with 15 existing cards

  Scenario: Successfully create a new flash card
    When I click on "Create New Card"
    Then I should see two empty canvases labeled "Side A" and "Side B"
    When I add text "What is the speed of light?" to Side A
    And I add text "299,792,458 meters per second" to Side B
    And I click "Save"
    Then I should see a success message
    And the card list should update to show 16 cards
    And the new card should appear at the bottom of the card list

  Scenario: Edit both sides simultaneously
    When I create a new card
    Then I should be able to edit Side A and Side B simultaneously
    And changes on one side should not affect the other side

  Scenario: View newly created card in the list
    When I create a new card with the question "What is Newton's Second Law?" on Side A
    And I add the answer "F = ma" on Side B
    Then I should see the new card in the card list
    And the card count should increase by 1----------------------------------------

File: ./docs/ui_specs.md
----------------------------------------
# Flash Card Creator SVG Layout Specification

## Purpose
This document outlines the SVG layout for the Flash Card Creator application, detailing each section and its components.

## Layout Overview

### Header
- **Purpose**: Displays the application title and navigation menu.
- **Components**:
  - `rect`: Background rectangle for the header.
  - `text`: Application title.
  - `rect` and `text`: Navigation menu.

### Sidebar
- **Purpose**: Displays current deck information and a list of cards.
- **Components**:
  - `rect`: Background rectangle for the sidebar.
  - `text`: Current deck title and card count.
  - `rect`: Background for the card list.
  - `text`: Card titles.

### Main Content Area
- **Purpose**: Card editor with toolbars and canvases for editing sides A and B of the cards.
- **Components**:
  - `rect`: Background rectangle for the main content area.
  - `rect`: Toolbar background.
  - Tool icons (rect, circle, polygon, text).
  - Undo/redo icons (paths).
  - Canvases for side A and side B (rectangles).
  - Example shapes and text on canvases (rect, circle, text).
  - Save button (rect and text).

### Footer
- **Purpose**: Displays application information and links.
- **Components**:
  - `rect`: Background rectangle for the footer.
  - `text`: Footer content.

### SVG Code
```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 900">
  <!-- Background -->
  <rect width="1200" height="900" fill="#f0f0f0"/>
  
  <!-- Header -->
  <rect width="1200" height="60" fill="#4a90e2"/>
  <text x="20" y="38" font-family="Arial, sans-serif" font-size="24" fill="white">Flash Card Creator</text>
  <rect x="1000" y="15" width="180" height="30" fill="#3a7bd5"/>
  <text x="1015" y="36" font-family="Arial, sans-serif" font-size="16" fill="white">Navigation Menu</text>
  
  <!-- Left Sidebar - Current Deck Info -->
  <rect x="0" y="60" width="250" height="840" fill="#e0e0e0"/>
  <text x="20" y="90" font-family="Arial, sans-serif" font-size="18" fill="#333">Current Deck: Physics</text>
  <text x="20" y="120" font-family="Arial, sans-serif" font-size="16" fill="#666">Cards: 15</text>
  
  <!-- Card List -->
  <rect x="10" y="140" width="230" height="660" fill="#f5f5f5"/>
  <text x="20" y="165" font-family="Arial, sans-serif" font-size="16" fill="#333">Card 1: Newton's First Law</text>
  <text x="20" y="195" font-family="Arial, sans-serif" font-size="16" fill="#333">Card 2: F = ma</text>
  <text x="20" y="225" font-family="Arial, sans-serif" font-size="16" fill="#333">Card 3: Energy Conservation</text>
  
  <!-- New Card Button -->
  <rect x="10" y="810" width="230" height="40" fill="#4caf50"/>
  <text x="70" y="835" font-family="Arial, sans-serif" font-size="16" fill="white">Create New Card</text>
  
  <!-- Main Content Area - Card Editor -->
  <rect x="250" y="60" width="950" height="800" fill="white"/>
  
  <!-- Toolbar -->
  <rect x="250" y="60" width="950" height="50" fill="#f5f5f5"/>
  <!-- Shape Tools -->
  <rect x="270" y="70" width="30" height="30" fill="#ddd" stroke="#999"/>
  <rect x="310" y="70" width="30" height="30" fill="#ddd" stroke="#999" rx="15"/>
  <polygon points="360,70 375,100 345,100" fill="#ddd" stroke="#999"/>
  <!-- Text Tool -->
  <rect x="400" y="70" width="30" height="30" fill="#ddd" stroke="#999"/>
  <text x="408" y="92" font-family="Arial, sans-serif" font-size="18" fill="#333">T</text>
  <!-- Color Picker -->
  <rect x="450" y="70" width="30" height="30" fill="url(#colorGradient)"/>
  <!-- Undo/Redo -->
  <path d="M500,85 h15 v-10 l10,10 l-10,10 v-10 h-15 z" fill="#666"/>
  <path d="M570,85 h-15 v-10 l-10,10 l10,10 v-10 h15 z" fill="#666"/>
  
  <!-- Side A Canvas -->
  <rect x="270" y="130" width="450" height="640" fill="white" stroke="#ccc" stroke-width="2"/>
  <text x="460" y="160" font-family="Arial, sans-serif" font-size="20" fill="#333">Side A</text>
  
  <!-- Side B Canvas -->
  <rect x="730" y="130" width="450" height="640" fill="white" stroke="#ccc" stroke-width="2"/>
  <text x="920" y="160" font-family="Arial, sans-serif" font-size="20" fill="#333">Side B</text>
  
  <!-- Example Shapes on Canvas -->
  <rect x="300" y="200" width="150" height="100" fill="#ff9800" stroke="#333" stroke-width="2"/>
  <circle cx="900" cy="300" r="60" fill="#e91e63" stroke="#333" stroke-width="2"/>
  <text x="350" y="400" font-family="Arial, sans-serif" font-size="18" fill="#333">Question</text>
  <text x="800" y="400" font-family="Arial, sans-serif" font-size="18" fill="#333">Answer</text>
  
  <!-- Save Button -->
  <rect x="1080" y="790" width="100" height="40" fill="#4caf50" rx="5"/>
  <text x="1110" y="815" font-family="Arial, sans-serif" font-size="16" fill="white">Save</text>
  
  <!-- Footer -->
  <rect x="0" y="860" width="1200" height="40" fill="#333"/>
  <text x="20" y="885" font-family="Arial, sans-serif" font-size="14" fill="white">App Information</text>
  <text x="1100" y="885" font-family="Arial, sans-serif" font-size="14" fill="white">Links</text>
  
  <!-- Definitions -->
  <defs>
    <linearGradient id="colorGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
      <stop offset="33%" style="stop-color:rgb(0,255,0);stop-opacity:1" />
      <stop offset="67%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
      <stop offset="100%" style="stop-color:rgb(255,255,0);stop-opacity:1" />
    </linearGradient>
  </defs>
</svg>
----------------------------------------

File: ./README.md
----------------------------------------
# Flash Card Creator

## Project Overview

Flash Card Creator is a web application designed to help users create and manage digital flash cards. This tool allows users to create visually rich flash cards and organize them into decks for easy management and export.

## Key Features

- Intuitive card editor with drag-and-drop interface
- Support for text and basic shapes
- Two-sided card creation (Side A and Side B)
- Deck management for organizing cards
- JSON export functionality for sharing decks
- Responsive design for desktop and tablet use

## Technology Stack

- Frontend: React with TypeScript
- State Management: Redux Toolkit
- UI Components: Material-UI (MUI)
- Canvas Manipulation: Konva.js with react-konva
- Form Handling: React Hook Form
- Routing: React Router
- Styling: Emotion (CSS-in-JS)
- Local Storage: localforage
- Testing: Jest, React Testing Library
- Build Tool: Webpack (via Create React App)

## Getting Started

### Prerequisites

- Node.js (v14.x or later)
- npm (v6.x or later) or Yarn

### Installation

1. Clone the repository:
   ```
   git clone https://github.com/yourusername/flash-card-creator.git
   cd flash-card-creator
   ```

2. Install dependencies:
   ```
   npm install
   ```
   or if using Yarn:
   ```
   yarn install
   ```

3. Start the development server:
   ```
   npm start
   ```
   or:
   ```
   yarn start
   ```

4. Open [http://localhost:3000](http://localhost:3000) to view the app in your browser.

## Project Structure

```
flash-card-creator/
├── public/            # Public assets
├── src/               # Source files
│   ├── components/    # Reusable React components
│   ├── pages/         # Page components
│   ├── hooks/         # Custom React hooks
│   ├── context/       # React context files
│   ├── services/      # API and service files
│   ├── utils/         # Utility functions
│   ├── types/         # TypeScript type definitions
│   ├── styles/        # Global styles and themes
│   └── constants/     # Application constants
├── tests/             # Test files
└── config/            # Configuration files
```

## Development Workflow

1. Create a new branch for each feature or bug fix.
2. Write tests for new functionality.
3. Ensure all tests pass before submitting a pull request.
4. Follow the established code style and conventions.
5. Update documentation as necessary.

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for more details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- [List any libraries, tools, or resources that significantly contributed to the project]----------------------------------------

File: ./public/index.html
----------------------------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flash Card Creator</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>----------------------------------------

File: ./src/index.tsx
----------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter as Router } from 'react-router-dom';
import App from './App';

console.log('Index.tsx: Script started');

document.addEventListener('DOMContentLoaded', () => {
  console.log('Index.tsx: DOM fully loaded');
  const rootElement = document.getElementById('root');
  
  if (rootElement) {
    console.log('Index.tsx: Root element found');
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <Router>
          <App />
        </Router>
      </React.StrictMode>
    );
    console.log('Index.tsx: App rendered');
  } else {
    console.error('Index.tsx: Root element not found');
  }
});

console.log('Index.tsx: Script ended');----------------------------------------

File: ./src/App.tsx
----------------------------------------
import React from 'react';
import { Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import Editor from './pages/Editor';
import DeckManagement from './pages/DeckManagement';
import Header from './components/layout/Header';
import Footer from './components/layout/Footer';
import './App.css';

const App: React.FC = () => {
  return (
    <div className="App">
      <Header />
      <main>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/editor" element={<Editor />} />
          <Route path="/editor/:cardId" element={<Editor />} />
          <Route path="/decks" element={<DeckManagement />} />
        </Routes>
      </main>
      <Footer />
    </div>
  );
};

export default App;----------------------------------------

File: ./src/App.md
----------------------------------------
# App

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/types/Shape.md
----------------------------------------
# Shape

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/types/Card.md
----------------------------------------
# Card

## Purpose
Defines the structure of a flash card, including all elements on both sides.

## Properties
- id: string
- deckId: string
- sideA: CardSide
- sideB: CardSide

## CardSide
- elements: Element[]

## Element
- id: string
- type: 'text' | 'rectangle' | 'circle'
- content: string (for text)
- style: ElementStyle
- position: Position

## ElementStyle
- fontFamily?: string
- fontSize?: number
- fontColor?: string
- backgroundColor?: string
- borderColor?: string
- borderWidth?: number

## Position
- x: number
- y: number
- width: number
- height: number

## TODO
- [ ] Implement the Card type
- [ ] Create functions for manipulating Card objects
- [ ] Add validation for Card properties
- [ ] Implement JSON serialization and deserialization methods----------------------------------------

File: ./src/types/Shape.ts
----------------------------------------
export interface Shape {
    id: string;
    type: 'rectangle' | 'circle' | 'text';
    x: number;
    y: number;
    width?: number;
    height?: number;
    radius?: number;
    text?: string;
    fill: string;
    stroke: string;
    strokeWidth: number;
  }
  ----------------------------------------

File: ./src/types/Card.ts
----------------------------------------
export interface CardSide {
  elements: CardElement[];
}

export interface ElementStyle {
  fontFamily?: string;
  fontSize?: number;
  fontColor?: string;
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: number;
}

export interface Position {
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface CardElement {
  id: string;
  type: 'text' | 'rectangle' | 'circle';
  content: string;
  style: ElementStyle;
  position: Position;
}

export interface Card {
  id: string;
  deckId: string;
  sideA: {
    elements: CardElement[];
  };
  sideB: {
    elements: CardElement[];
  };
}
----------------------------------------

File: ./src/types/Deck.md
----------------------------------------
# Deck

## Purpose
Defines the structure of a deck, which is a collection of flash cards.

## Properties
- id: string
- name: string
- description: string
- cards: Card[]
- createdAt: Date
- updatedAt: Date

## Methods
- addCard(card: Card): void
- removeCard(cardId: string): void
- updateCard(cardId: string, updatedCard: Card): void
- exportToJSON(): string
- importFromJSON(json: string): void

## TODO
- [ ] Implement the Deck type
- [ ] Create CRUD methods for managing cards in the deck
- [ ] Implement the exportToJSON method
- [ ] Implement the importFromJSON method
- [ ] Add validation for Deck properties----------------------------------------

File: ./src/types/Deck.ts
----------------------------------------
import { Card } from './Card';

export interface Deck {
  id: string;
  name: string;
  description: string;
  cards: Card[];
  createdAt: Date;
  updatedAt: Date;
}
----------------------------------------

File: ./src/context/ThemeContext.md
----------------------------------------
# ThemeContext

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/context/AppStateContext.md
----------------------------------------
# AppStateContext

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/context/AppStateContext.tsx
----------------------------------------
import React, { createContext, useContext, useReducer, ReactNode } from 'react';
import { Card } from '../types/Card';
import { Deck } from '../types/Deck';

interface AppState {
  cards: Card[];
  decks: Deck[];
}

type Action =
  | { type: 'ADD_CARD'; payload: Card }
  | { type: 'UPDATE_CARD'; payload: Card }
  | { type: 'DELETE_CARD'; payload: string }
  | { type: 'ADD_DECK'; payload: Deck }
  | { type: 'UPDATE_DECK'; payload: Deck }
  | { type: 'DELETE_DECK'; payload: string };

const initialState: AppState = {
  cards: [],
  decks: [],
};

const AppStateContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<Action>;
} | undefined>(undefined);

function appStateReducer(state: AppState, action: Action): AppState {
  switch (action.type) {
    case 'ADD_CARD':
      return { ...state, cards: [...state.cards, action.payload] };
    case 'UPDATE_CARD':
      return {
        ...state,
        cards: state.cards.map((card) =>
          card.id === action.payload.id ? action.payload : card
        ),
      };
    case 'DELETE_CARD':
      return {
        ...state,
        cards: state.cards.filter((card) => card.id !== action.payload),
      };
    case 'ADD_DECK':
      return { ...state, decks: [...state.decks, action.payload] };
    case 'UPDATE_DECK':
      return {
        ...state,
        decks: state.decks.map((deck) =>
          deck.id === action.payload.id ? action.payload : deck
        ),
      };
    case 'DELETE_DECK':
      return {
        ...state,
        decks: state.decks.filter((deck) => deck.id !== action.payload),
      };
    default:
      return state;
  }
}

export function AppStateProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appStateReducer, initialState);
  return (
    <AppStateContext.Provider value={{ state, dispatch }}>
      {children}
    </AppStateContext.Provider>
  );
}

export function useAppState() {
  const context = useContext(AppStateContext);
  if (context === undefined) {
    throw new Error('useAppState must be used within an AppStateProvider');
  }
  return context;
}----------------------------------------

File: ./src/constants/appConstants.md
----------------------------------------
# appConstants

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/App.css
----------------------------------------
.App {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
  
  header {
    background-color: #f0f0f0;
    padding: 10px;
    margin-bottom: 20px;
  }
  
  nav ul {
    list-style-type: none;
    padding: 0;
  }
  
  nav ul li {
    display: inline;
    margin-right: 10px;
  }
  
  main {
    background-color: #ffffff;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 5px;
  }----------------------------------------

File: ./src/utils/shapes.md
----------------------------------------
# Shape Utilities

## Purpose
The shapes utility module provides helper functions for working with shape data in the application.

## Dependencies
- ../types/Shape

## Main Functionality
1. Create shape objects
2. Perform calculations on shapes (e.g., area, perimeter)
3. Transform shape data
4. Validate shape properties

## Utility Functions
```typescript
// Shape creation
createRectangle(x: number, y: number, width: number, height: number): Rectangle;
createCircle(x: number, y: number, radius: number): Circle;
createText(x: number, y: number, text: string): Text;

// Shape calculations
calculateArea(shape: Shape): number;
calculatePerimeter(shape: Shape): number;

// Shape transformations
scaleShape(shape: Shape, factor: number): Shape;
rotateShape(shape: Shape, angle: number): Shape;

// Validation
isValidShape(shape: Shape): boolean;
```

## TODO
- [ ] Implement shape creation functions
- [ ] Add calculation functions
- [ ] Create transformation utilities
- [ ] Implement shape validation
- [ ] Write unit tests for all functions----------------------------------------

File: ./src/utils/colorUtils.md
----------------------------------------
# Color Utilities

## Purpose
The colorUtils module provides helper functions for working with colors in the application.

## Dependencies
None

## Main Functionality
1. Convert between color formats (HEX, RGB, HSL)
2. Generate color palettes
3. Manipulate colors (lighten, darken, saturate)
4. Calculate color contrast

## Utility Functions
```typescript
// Color conversion
hexToRgb(hex: string): { r: number; g: number; b: number };
rgbToHex(r: number, g: number, b: number): string;
rgbToHsl(r: number, g: number, b: number): { h: number; s: number; l: number };

// Color manipulation
lightenColor(color: string, amount: number): string;
darkenColor(color: string, amount: number): string;
saturateColor(color: string, amount: number): string;

// Color palette
generateComplementaryColor(color: string): string;
generateAnalogousColors(color: string): string[];

// Contrast
calculateContrast(color1: string, color2: string): number;
```

## TODO
- [ ] Implement color conversion functions
- [ ] Create color manipulation utilities
- [ ] Add palette generation functions
- [ ] Implement contrast calculation
- [ ] Write unit tests for all functions----------------------------------------

File: ./src/utils/validators.md
----------------------------------------
# validators

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/styles/globalStyles.md
----------------------------------------
# globalStyles

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/styles/globalStyles.ts
----------------------------------------
import { css } from '@emotion/react';

export const globalStyles = css`
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  .App {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }

  header {
    background-color: #4a90e2;
    padding: 10px;
    margin-bottom: 20px;
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  nav ul {
    list-style-type: none;
    padding: 0;
  }

  nav ul li {
    display: inline;
    margin-right: 10px;
  }

  main {
    background-color: #ffffff;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 5px;
  }

  aside {
    width: 250px;
    background-color: #e0e0e0;
    padding: 10px;
    height: 100vh;
  }

  footer {
    width: 100%;
    height: 40px;
    background-color: #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px;
    color: white;
  }
`;
----------------------------------------

File: ./src/styles/theme.md
----------------------------------------
# theme

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/layout/Footer.md
----------------------------------------
# Footer

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/layout/Footer.tsx
----------------------------------------
import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer style={styles.footer}>
      <p style={styles.footerText}>App Information</p>
      <p style={styles.footerText}>Links</p>
    </footer>
  );
};

const styles = {
  footer: {
    width: '100%',
    height: '40px',
    backgroundColor: '#333',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: '0 20px',
    color: 'white'
  },
  footerText: {
    fontSize: '14px',
  },
};

export default Footer;
----------------------------------------

File: ./src/components/layout/Header.md
----------------------------------------
# Header

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/layout/Sidebar.md
----------------------------------------
# Sidebar

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/layout/Header.tsx
----------------------------------------
import React from 'react';

const Header: React.FC = () => {
  return (
    <header style={styles.header}>
      <h1 style={styles.title}>Flash Card Creator</h1>
      <div style={styles.navigation}>
        <a href="/" style={styles.navLink}>Home</a>
        <a href="/editor" style={styles.navLink}>Create New Card</a>
        <a href="/decks" style={styles.navLink}>Manage Decks</a>
      </div>
    </header>
  );
};

const styles = {
  header: {
    width: '100%',
    height: '60px',
    backgroundColor: '#4a90e2',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: '0 20px',
    color: 'white'
  },
  title: {
    fontSize: '24px',
  },
  navigation: {
    display: 'flex',
    gap: '20px',
  },
  navLink: {
    color: 'white',
    textDecoration: 'none',
  },
};

export default Header;
----------------------------------------

File: ./src/components/layout/Sidebar.tsx
----------------------------------------
import React from 'react';
import { Link } from 'react-router-dom';

const Sidebar: React.FC = () => {
  return (
    <aside style={styles.sidebar}>
      <h2 style={styles.deckTitle}>Current Deck: Physics</h2>
      <p style={styles.cardCount}>Cards: 15</p>
      <div style={styles.cardList}>
        <p>Card 1: Newton's First Law</p>
        <p>Card 2: F = ma</p>
        <p>Card 3: Energy Conservation</p>
        {/* Add more cards as necessary */}
      </div>
      <Link to="/editor">
        <button style={styles.newCardButton}>Create New Card</button>
      </Link>
    </aside>
  );
};

const styles = {
  sidebar: {
    width: '250px',
    backgroundColor: '#e0e0e0',
    padding: '10px',
    height: '100vh',
  },
  deckTitle: {
    fontSize: '18px',
    color: '#333',
  },
  cardCount: {
    fontSize: '16px',
    color: '#666',
  },
  cardList: {
    backgroundColor: '#f5f5f5',
    padding: '10px',
    marginTop: '10px',
    overflowY: 'auto' as 'auto', // Fix type error
    height: 'calc(100% - 180px)',
  },
  newCardButton: {
    width: '100%',
    height: '40px',
    backgroundColor: '#4caf50',
    color: 'white',
    border: 'none',
    cursor: 'pointer',
    marginTop: '10px',
  },
};

export default Sidebar;
----------------------------------------

File: ./src/components/cards/ElementEditor.tsx
----------------------------------------
import React, { useState } from 'react';
import { CardElement } from '../../types/Card';

interface ElementEditorProps {
  element: CardElement;
  updateElement: (id: string, updatedElement: CardElement) => void;
  deleteElement: (id: string) => void;
  onContentChange: (content: string) => void;
}

const ElementEditor: React.FC<ElementEditorProps> = ({ element, updateElement, deleteElement, onContentChange }) => {
  const [content, setContent] = useState(element.content);
  const [style, setStyle] = useState(element.style);
  const [position, setPosition] = useState(element.position);

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newContent = e.target.value;
    setContent(newContent);
    onContentChange(newContent);
  };

  const handleSave = () => {
    const updatedElement = { ...element, content, style, position };
    updateElement(element.id, updatedElement);
  };

  return (
    <div style={styles.elementEditor}>
      {element.type === 'text' && (
        <textarea
          value={content}
          onChange={handleContentChange}
          placeholder="Enter text"
          style={styles.textarea}
        />
      )}
      <button onClick={handleSave}>Save</button>
      <button onClick={() => deleteElement(element.id)}>Delete</button>
    </div>
  );
};

const styles = {
  elementEditor: {
    marginBottom: '10px',
  },
  textarea: {
    width: '100%',
    height: '100px',
  },
};

export default ElementEditor;----------------------------------------

File: ./src/components/cards/CardList.md
----------------------------------------
# CardList

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/cards/CardEditor.md
----------------------------------------
# CardEditor

## Purpose
The CardEditor component is the core interface for creating and editing flash cards. It provides a canvas-based environment where users can add shapes, text, and manipulate elements to design both sides of a flash card simultaneously.

## Dependencies
- react
- react-konva
- @emotion/styled
- react-colorful
- ../../types/Card

## Props
- card?: Card (optional, for editing an existing card)
- onSave: (card: Card) => void

## Main Functionality
1. Display Side A and Side B of the card side by side for simultaneous editing
2. Provide a canvas for drawing and manipulating shapes and text on each side
3. Offer tools for adding rectangles, circles, and text elements
4. Enable selection, movement, resizing, and deletion of elements
5. Provide color selection for shapes and text
6. Allow focusing on one side at a time for detailed editing
7. Save card data for both sides

## TODO
- [x] Implement basic structure
- [x] Add simultaneous display of Side A and Side B
- [x] Implement canvas setup with react-konva for both sides
- [x] Create toolbar with shape and text tools
- [x] Implement shape and text addition functionality
- [x] Add selection and manipulation capabilities
- [x] Create save functionality for both sides
- [ ] Add undo/redo feature
- [x] Implement color picking for elements
- [ ] Write unit tests for core functions
- [x] Style component using Emotion----------------------------------------

File: ./src/components/cards/SideEditor.tsx
----------------------------------------
import React from 'react';
import { CardElement } from '../../types/Card';
import ElementEditor from './ElementEditor'; 

interface SideEditorProps {
  side: string;
  content: CardElement[];
  setContent: React.Dispatch<React.SetStateAction<CardElement[]>>;
  undo: () => void;
  redo: () => void;
  onContentChange: (content: string) => void;
}

const SideEditor: React.FC<SideEditorProps> = ({ side, content, setContent, undo, redo, onContentChange }) => {
  const addElement = (type: 'text' | 'rectangle' | 'circle') => {
    const newElement: CardElement = {
      id: Date.now().toString(),
      type,
      content: '',
      style: {},
      position: { x: 0, y: 0, width: 100, height: 100 },
    };
    setContent([...content, newElement]);
  };

  const updateElement = (id: string, updatedElement: CardElement) => {
    setContent(content.map(el => (el.id === id ? updatedElement : el)));
  };

  const deleteElement = (id: string) => {
    setContent(content.filter(el => el.id !== id));
  };

  return (
    <div style={styles.side}>
      <h3>Side {side}</h3>
      {content.map(el => (
        <ElementEditor
          key={el.id}
          element={el}
          updateElement={updateElement}
          deleteElement={deleteElement}
          onContentChange={onContentChange}
        />
      ))}
      <button onClick={() => addElement('text')}>Add Text</button>
      <button onClick={() => addElement('rectangle')}>Add Rectangle</button>
      <button onClick={() => addElement('circle')}>Add Circle</button>
      <button onClick={undo}>Undo</button>
      <button onClick={redo}>Redo</button>
    </div>
  );
};

const styles = {
  side: {
    flex: 1,
    padding: '10px',
    border: '1px solid #ccc',
    margin: '10px',
  },
};

export default SideEditor;----------------------------------------

File: ./src/components/cards/CardEditor.tsx
----------------------------------------
import React, { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Rect, Circle, Text, Transformer } from 'react-konva';
import Konva from 'konva';
import { HexColorPicker } from 'react-colorful';
import styled from '@emotion/styled';
import { CardElement, Card } from '../../types/Card';

interface CardEditorProps {
  card?: Card;
  onSave: (card: Card) => void;
}

const CardEditor: React.FC<CardEditorProps> = ({ card, onSave }) => {
  const [sideAElements, setSideAElements] = useState<CardElement[]>(card?.sideA.elements || []);
  const [sideBElements, setSideBElements] = useState<CardElement[]>(card?.sideB.elements || []);
  const [selectedId, selectShape] = useState<string | null>(null);
  const [tool, setTool] = useState<'select' | 'rectangle' | 'circle' | 'text'>('select');
  const [color, setColor] = useState("#000000");
  const stageARef = useRef<Konva.Stage>(null);
  const stageBRef = useRef<Konva.Stage>(null);
  const layerARef = useRef<Konva.Layer>(null);
  const layerBRef = useRef<Konva.Layer>(null);
  const transformerRef = useRef<Konva.Transformer>(null);

  useEffect(() => {
    if (selectedId) {
      const stage = selectedId.startsWith('A') ? stageARef.current : stageBRef.current;
      const layer = selectedId.startsWith('A') ? layerARef.current : layerBRef.current;
      const transformer = transformerRef.current;
      
      if (stage && layer && transformer) {
        const selectedNode = stage.findOne('#' + selectedId);
        if (selectedNode) {
          transformer.nodes([selectedNode]);
          layer.add(transformer);
          layer.batchDraw();
        }
      }
    }
  }, [selectedId]);

  const addElement = (side: 'A' | 'B', type: 'rectangle' | 'circle' | 'text') => {
    const newElement: CardElement = {
      id: `${side}${Date.now()}`,
      type,
      content: type === 'text' ? 'New Text' : '',
      style: { backgroundColor: color, borderColor: color, borderWidth: 2, fontColor: color },
      position: { x: 50, y: 50, width: 100, height: 100 },
    };
    if (side === 'A') {
      setSideAElements([...sideAElements, newElement]);
    } else {
      setSideBElements([...sideBElements, newElement]);
    }
  };

  const updateElement = (side: 'A' | 'B', id: string, newProps: Partial<CardElement>) => {
    const updateElements = (elements: CardElement[]) =>
      elements.map(el => el.id === id ? { ...el, ...newProps } : el);
    
    if (side === 'A') {
      setSideAElements(updateElements(sideAElements));
    } else {
      setSideBElements(updateElements(sideBElements));
    }
  };

  const handleStageClick = (side: 'A' | 'B', e: Konva.KonvaEventObject<MouseEvent>) => {
    const clickedOnEmpty = e.target === e.target.getStage();
    if (clickedOnEmpty) {
      selectShape(null);
      if (tool !== 'select') {
        addElement(side, tool);
        setTool('select');
      }
    }
  };

  const renderShape = (side: 'A' | 'B', element: CardElement) => {
    const shapeProps = {
      id: element.id,
      x: element.position.x,
      y: element.position.y,
      width: element.position.width,
      height: element.position.height,
      fill: element.style.backgroundColor,
      stroke: element.style.borderColor,
      strokeWidth: element.style.borderWidth,
      draggable: true,
      onClick: () => selectShape(element.id),
      onDragEnd: (e: Konva.KonvaEventObject<DragEvent>) => {
        updateElement(side, element.id, {
          position: {
            ...element.position,
            x: e.target.x(),
            y: e.target.y(),
          },
        });
      },
      onTransformEnd: (e: Konva.KonvaEventObject<Event>) => {
        const node = e.target;
        updateElement(side, element.id, {
          position: {
            ...element.position,
            x: node.x(),
            y: node.y(),
            width: node.width() * node.scaleX(),
            height: node.height() * node.scaleY(),
          },
        });
      },
    };

    switch (element.type) {
      case 'rectangle':
        return <Rect key={element.id} {...shapeProps} />;
      case 'circle':
        return <Circle key={element.id} {...shapeProps} radius={element.position.width / 2} />;
      case 'text':
        return (
          <Text
            key={element.id}
            {...shapeProps}
            text={element.content}
            fontSize={element.style.fontSize || 16}
            fill={element.style.fontColor}
          />
        );
      default:
        return null;
    }
  };

  const handleSave = () => {
    if (card) {
      onSave({
        ...card,
        sideA: { elements: sideAElements },
        sideB: { elements: sideBElements }
      });
    } else {
      onSave({
        id: Date.now().toString(),
        deckId: '',
        sideA: { elements: sideAElements },
        sideB: { elements: sideBElements }
      });
    }
  };

  return (
    <EditorContainer>
      <h2>Edit Card</h2>
      <EditArea>
        <ToolbarContainer>
          <Toolbar>
            <ToolButton onClick={() => setTool('select')} active={tool === 'select'}>Select</ToolButton>
            <ToolButton onClick={() => setTool('rectangle')} active={tool === 'rectangle'}>Rectangle</ToolButton>
            <ToolButton onClick={() => setTool('circle')} active={tool === 'circle'}>Circle</ToolButton>
            <ToolButton onClick={() => setTool('text')} active={tool === 'text'}>Text</ToolButton>
          </Toolbar>
          <ColorPickerContainer>
            <HexColorPicker color={color} onChange={setColor} />
          </ColorPickerContainer>
        </ToolbarContainer>
        <SidesContainer>
          <SideContainer>
            <h3>Side A</h3>
            <StageContainer>
              <Stage
                width={320}
                height={240}
                ref={stageARef}
                onClick={(e) => handleStageClick('A', e)}
              >
                <Layer ref={layerARef}>
                  {sideAElements.map((element) => renderShape('A', element))}
                  <Transformer ref={transformerRef} />
                </Layer>
              </Stage>
            </StageContainer>
          </SideContainer>
          <SideContainer>
            <h3>Side B</h3>
            <StageContainer>
              <Stage
                width={320}
                height={240}
                ref={stageBRef}
                onClick={(e) => handleStageClick('B', e)}
              >
                <Layer ref={layerBRef}>
                  {sideBElements.map((element) => renderShape('B', element))}
                  <Transformer ref={transformerRef} />
                </Layer>
              </Stage>
            </StageContainer>
          </SideContainer>
        </SidesContainer>
        <SaveButton onClick={handleSave}>Save Card</SaveButton>
      </EditArea>
    </EditorContainer>
  );
};

const EditorContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
`;

const EditArea = styled.div`
  background-color: #f0f0f0;
  border-radius: 8px;
  padding: 20px;
  width: 100%;
`;

const ToolbarContainer = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
`;

const Toolbar = styled.div`
  display: flex;
  background-color: #ffffff;
  border-radius: 8px;
  overflow: hidden;
`;

const ToolButton = styled.button<{ active?: boolean }>`
  padding: 10px 20px;
  background-color: ${props => props.active ? '#4a90e2' : 'transparent'};
  color: ${props => props.active ? '#ffffff' : '#333333'};
  border: none;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;

  &:hover {
    background-color: ${props => props.active ? '#3a7bd5' : '#f0f0f0'};
  }
`;

const ColorPickerContainer = styled.div`
  .react-colorful {
    width: 120px;
    height: 120px;
  }
`;

const SidesContainer = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
`;

const SideContainer = styled.div`
  width: 48%;

  h3 {
    margin-bottom: 10px;
  }
`;

const StageContainer = styled.div`
  border: 1px solid #cccccc;
  border-radius: 4px;
  overflow: hidden;
`;

const SaveButton = styled.button`
  padding: 10px 20px;
  background-color: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s;

  &:hover {
    background-color: #45a049;
  }
`;

export default CardEditor;----------------------------------------

File: ./src/components/cards/__tests__/SideEditor.test.tsx
----------------------------------------
import React from 'react';
import { render, fireEvent, screen, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import SideEditor from '../SideEditor';
import { CardElement } from '../../../types/Card';

describe('SideEditor Component', () => {
  const renderSideEditor = (content: CardElement[], setContent: any, undo: any, redo: any) =>
    render(
      <SideEditor
        side="A"
        content={content}
        setContent={setContent}
        undo={undo}
        redo={redo}
      />
    );

  it('should add, undo, and redo elements correctly', () => {
    let content: CardElement[] = [];
    const setContent = jest.fn((newContent) => (content = newContent));
    const undo = jest.fn();
    const redo = jest.fn();

    renderSideEditor(content, setContent, undo, redo);

    act(() => {
      // Add text element
      fireEvent.click(screen.getByText('Add Text'));
    });
    expect(setContent).toHaveBeenCalled();
    expect(content).toHaveLength(1);

    // Undo action
    act(() => {
      fireEvent.click(screen.getByText('Undo'));
    });
    expect(undo).toHaveBeenCalled();

    // Redo action
    act(() => {
      fireEvent.click(screen.getByText('Redo'));
    });
    expect(redo).toHaveBeenCalled();
  });
});
----------------------------------------

File: ./src/components/cards/__tests__/CardEditor.test.tsx
----------------------------------------
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { BrowserRouter as Router } from 'react-router-dom';
import CardEditor from '../CardEditor';
import { saveCards } from '../../../services/storage';

jest.mock('../../../services/storage', () => ({
  getCards: jest.fn(() => []),
  saveCards: jest.fn(),
}));

jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => jest.fn(),
}));

describe('CardEditor Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ... other tests ...

  it('should handle undo and redo operations', async () => {
    render(
      <Router>
        <CardEditor />
      </Router>
    );

    // Add content to Side A
    const addTextButtonsA = screen.getAllByText('Add Text');
    fireEvent.click(addTextButtonsA[0]);
    const textAreasA = screen.getAllByPlaceholderText('Enter text');
    fireEvent.change(textAreasA[0], { target: { value: 'Side A Content' } });

    await waitFor(() => {
      expect(screen.getByDisplayValue('Side A Content')).toBeInTheDocument();
    });

    // Undo
    const undoButtons = screen.getAllByText('Undo');
    fireEvent.click(undoButtons[0]);

    await waitFor(() => {
      expect(screen.queryByDisplayValue('Side A Content')).not.toBeInTheDocument();
    });

    // Redo
    const redoButtons = screen.getAllByText('Redo');
    fireEvent.click(redoButtons[0]);

    await waitFor(() => {
      expect(screen.getByDisplayValue('Side A Content')).toBeInTheDocument();
    });
  });
});----------------------------------------

File: ./src/components/cards/CardViewer.md
----------------------------------------
# CardViewer

## Purpose
The CardViewer component displays a single flash card, allowing users to flip between Side A and Side B. It's used in both study mode and deck management.

## Dependencies
- react
- @material-ui/core
- ../../types/Card
- ../../hooks/useCard

## Props
- cardId: string
- onFlip?: () => void

## Main Functionality
1. Display the current side of the card (A or B)
2. Provide a mechanism to flip the card
3. Render shapes and text as defined in the card data
4. Optionally trigger onFlip callback when the card is flipped

## Component Structure
```typescript
const CardViewer: React.FC<CardViewerProps> = ({ cardId, onFlip }) => {
  // State for current side
  // Card data fetching logic

  return (
    <div className="card-viewer">
      {/* Card content rendering */}
      {/* Flip button */}
    </div>
  );
};
```

## TODO
- [ ] Implement card data fetching
- [ ] Create rendering logic for shapes and text
- [ ] Add flip functionality
- [ ] Implement smooth flip animation
- [ ] Write unit tests----------------------------------------

File: ./src/components/cards/CardViewer.tsx
----------------------------------------
import React, { useState } from 'react';
import { Card } from '../../types/Card';

interface CardViewerProps {
  card: Card;
}

const CardViewer: React.FC<CardViewerProps> = ({ card }) => {
  const [showFront, setShowFront] = useState(true);

  const flipCard = () => {
    setShowFront(!showFront);
  };

  return (
    <div className="card-viewer" onClick={flipCard}>
      <h2>Card Viewer</h2>
      {showFront ? (
        <div>
          <h3>Front</h3>
          {card.sideA.elements.map((element) => (
            <div key={element.id}>{element.content}</div>
          ))}
        </div>
      ) : (
        <div>
          <h3>Back</h3>
          {card.sideB.elements.map((element) => (
            <div key={element.id}>{element.content}</div>
          ))}
        </div>
      )}
    </div>
  );
};

export default CardViewer;
----------------------------------------

File: ./src/components/decks/DeckItem.tsx
----------------------------------------
import React from 'react';
import { Deck } from '../../types/Deck';

interface DeckItemProps {
  deck: Deck;
}

const DeckItem: React.FC<DeckItemProps> = ({ deck }) => {
  return (
    <li>
      <h3>{deck.name}</h3>
      <p>{deck.description}</p>
      <p>Cards: {deck.cards.length}</p>
    </li>
  );
};

export default DeckItem;
----------------------------------------

File: ./src/components/decks/DeckItem.md
----------------------------------------
# DeckItem

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/decks/DeckManager.md
----------------------------------------
# DeckManager

## Purpose
The DeckManager component provides an interface for creating, viewing, updating, and deleting decks of flash cards. It also allows users to manage cards within each deck and export decks to JSON.

## Dependencies
- react
- @emotion/styled
- react-beautiful-dnd
- ../../hooks/useDeck
- ../../services/storage
- ../cards/CardList
- ../../types/Deck

## Main Functionality
1. Display a list of all decks
2. Allow creation of new decks
3. Enable editing of deck names and descriptions
4. Provide functionality to delete decks
5. Display cards within a selected deck
6. Allow reordering of cards within a deck
7. Provide options to add or remove cards from a deck
8. Allow exporting decks to JSON

## TODO
- [x] Implement basic structure
- [x] Create new deck functionality
- [ ] Implement deck list display
- [ ] Add deck editing and deletion features
- [ ] Implement deck selection
- [ ] Create card list display for selected deck
- [ ] Add drag-and-drop reordering for cards
- [ ] Implement add/remove card functionality
- [ ] Add JSON export functionality
- [ ] Write unit tests for CRUD operations
- [ ] Integrate with storage service for persistence
- [ ] Style component using Emotion----------------------------------------

File: ./src/components/decks/DeckManager.tsx
----------------------------------------
import React, { useState, useEffect } from 'react';
import { Deck } from '../../types/Deck';
import { saveDecks, getDecks } from '../../services/storage';
import DeckList from './DeckList';

const DeckManager: React.FC = () => {
  const [decks, setDecks] = useState<Deck[]>([]);
  const [newDeckName, setNewDeckName] = useState('');
  const [newDeckDescription, setNewDeckDescription] = useState('');

  useEffect(() => {
    setDecks(getDecks());
  }, []);

  const createDeck = () => {
    if (newDeckName.trim() === '') {
      alert('Deck name cannot be empty');
      return;
    }

    const newDeck: Deck = {
      id: Date.now().toString(),
      name: newDeckName,
      description: newDeckDescription,
      cards: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const updatedDecks = [...decks, newDeck];
    setDecks(updatedDecks);
    saveDecks(updatedDecks);
    setNewDeckName('');
    setNewDeckDescription('');
  };

  return (
    <div>
      <h2>Deck Manager</h2>
      <div>
        <input
          type="text"
          value={newDeckName}
          onChange={(e) => setNewDeckName(e.target.value)}
          placeholder="Enter deck name"
        />
        <input
          type="text"
          value={newDeckDescription}
          onChange={(e) => setNewDeckDescription(e.target.value)}
          placeholder="Enter deck description"
        />
        <button onClick={createDeck}>Create New Deck</button>
      </div>
      <DeckList decks={decks} />
    </div>
  );
};

export default DeckManager;
----------------------------------------

File: ./src/components/decks/DeckList.tsx
----------------------------------------
import React from 'react';
import { Deck } from '../../types/Deck';
import DeckItem from './DeckItem';

interface DeckListProps {
  decks: Deck[];
}

const DeckList: React.FC<DeckListProps> = ({ decks }) => {
  return (
    <ul>
      {decks.map((deck) => (
        <DeckItem key={deck.id} deck={deck} />
      ))}
    </ul>
  );
};

export default DeckList;
----------------------------------------

File: ./src/components/decks/DeckList.md
----------------------------------------
# DeckList

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/common/Input.md
----------------------------------------
# Input

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/common/Modal.md
----------------------------------------
# Modal

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/common/ErrorMessage.tsx
----------------------------------------
import React from 'react';

interface ErrorMessageProps {
  message: string;
}

const ErrorMessage: React.FC<ErrorMessageProps> = ({ message }) => {
  return (
    <div className="error-message">
      <p>{message}</p>
    </div>
  );
};

export default ErrorMessage;----------------------------------------

File: ./src/components/common/Button.md
----------------------------------------
# Button

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/common/ColorPicker.md
----------------------------------------
# ColorPicker

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/components/common/LoadingSpinner.tsx
----------------------------------------
import React from 'react';

const LoadingSpinner: React.FC = () => {
  return (
    <div className="loading-spinner">
      <p>Loading...</p>
    </div>
  );
};

export default LoadingSpinner;----------------------------------------

File: ./src/__tests__/App.test.tsx
----------------------------------------
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { BrowserRouter as Router } from 'react-router-dom';
import App from '../App';

test('renders App component', () => {
  render(
    <Router>
      <App />
    </Router>
  );
  const headerElement = screen.getByText(/Flash Card Creator/i);
  expect(headerElement).toBeInTheDocument();
});----------------------------------------

File: ./src/__tests__/components/decks/DeckManager.test.tsx
----------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import DeckManager from '../../../components/decks/DeckManager';
import * as storage from '../../../services/storage';

jest.mock('../../../services/storage');

describe('DeckManager', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders the deck manager', () => {
    render(<DeckManager />);
    expect(screen.getByText('Deck Manager')).toBeInTheDocument();
  });

  it('creates a new deck', () => {
    const mockSaveDecks = jest.spyOn(storage, 'saveDecks');
    render(<DeckManager />);
    
    fireEvent.change(screen.getByPlaceholderText('Enter deck name'), { target: { value: 'New Deck' } });
    fireEvent.change(screen.getByPlaceholderText('Enter deck description'), { target: { value: 'Description' } });
    fireEvent.click(screen.getByText('Create New Deck'));

    expect(mockSaveDecks).toHaveBeenCalled();
    expect(screen.getByText('New Deck')).toBeInTheDocument();
  });
});
----------------------------------------

File: ./src/index.md
----------------------------------------
# index

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/hooks/useCanvas.md
----------------------------------------
# useCanvas

## Purpose
The useCanvas hook manages the state and operations for the canvas used in the CardEditor component.

## Dependencies
- react
- konva
- ../types/Shape

## Functionality
1. Manage canvas state (shapes, selected shape, etc.)
2. Provide functions for adding, modifying, and deleting shapes
3. Handle shape selection and deselection
4. Manage undo/redo functionality

## Hook Structure
```typescript
const useCanvas = (initialShapes: Shape[] = []) => {
  // State management
  // Shape manipulation functions
  // Undo/redo logic

  return {
    shapes,
    selectedShape,
    addShape,
    updateShape,
    deleteShape,
    selectShape,
    undo,
    redo,
  };
};
```

## TODO
- [ ] Implement shape state management
- [ ] Create shape manipulation functions
- [ ] Add selection logic
- [ ] Implement undo/redo functionality
- [ ] Write unit tests----------------------------------------

File: ./src/hooks/useElement.ts
----------------------------------------
import { useState, useCallback } from 'react';
import { CardElement } from '../types/Card';

const useElement = (initialElements: CardElement[] = []) => {
  const [elements, setElements] = useState<CardElement[]>(initialElements);

  const addElement = (element: CardElement) => {
    setElements([...elements, element]);
  };

  const updateElement = (id: string, newElement: CardElement) => {
    setElements(elements.map(element => (element.id === id ? newElement : element)));
  };

  const deleteElement = (id: string) => {
    setElements(elements.filter(element => element.id !== id));
  };

  return {
    elements,
    addElement,
    updateElement,
    deleteElement,
  };
};

export default useElement;
----------------------------------------

File: ./src/hooks/useCanvas.ts
----------------------------------------
import { useState, useCallback } from 'react';
import { Shape } from '../types/Shape';

const useCanvas = (initialShapes: Shape[] = []) => {
  const [shapes, setShapes] = useState<Shape[]>(initialShapes);
  const [selectedShape, setSelectedShape] = useState<Shape | null>(null);

  const addShape = (shape: Shape) => {
    setShapes([...shapes, shape]);
  };

  const updateShape = (id: string, newShape: Shape) => {
    setShapes(shapes.map(shape => (shape.id === id ? newShape : shape)));
  };

  const deleteShape = (id: string) => {
    setShapes(shapes.filter(shape => shape.id !== id));
  };

  const selectShape = (id: string) => {
    setSelectedShape(shapes.find(shape => shape.id === id) || null);
  };

  return {
    shapes,
    selectedShape,
    addShape,
    updateShape,
    deleteShape,
    selectShape,
  };
};

export default useCanvas;
----------------------------------------

File: ./src/hooks/useDeck.md
----------------------------------------
# useDeck

## Purpose
The useDeck hook manages deck-related operations and state, providing an interface for components to interact with deck data.

## Dependencies
- react
- ../services/storage
- ../types/Deck
- ../types/Card

## Functionality
1. Fetch and manage deck data
2. Provide CRUD operations for decks
3. Handle card management within decks
4. Manage deck selection state

## Hook Structure
```typescript
const useDeck = () => {
  // Deck state management
  // CRUD operations
  // Card management functions

  return {
    decks,
    selectedDeck,
    createDeck,
    updateDeck,
    deleteDeck,
    selectDeck,
    addCardToDeck,
    removeCardFromDeck,
    reorderCardsInDeck,
  };
};
```

## TODO
- [ ] Implement deck state management
- [ ] Create CRUD operations for decks
- [ ] Add card management functions
- [ ] Integrate with storage service
- [ ] Write unit tests----------------------------------------

File: ./src/react-app-env.d.ts
----------------------------------------
/// <reference types="react-scripts" />
----------------------------------------

File: ./src/setupTest.js
----------------------------------------
import '@testing-library/jest-dom';----------------------------------------

File: ./src/pages/DeckManagement.tsx
----------------------------------------
import React from 'react';
import DeckManager from '../components/decks/DeckManager';

const DeckManagement: React.FC = () => {
  return (
    <div>
      <h1>Deck Management</h1>
      <DeckManager />
    </div>
  );
};

export default DeckManagement;
----------------------------------------

File: ./src/pages/Home.tsx
----------------------------------------
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { getCards } from '../services/storage';
import { Card } from '../types/Card';

const Home: React.FC = () => {
  const [cards, setCards] = useState<Card[]>([]);

  useEffect(() => {
    const fetchedCards = getCards();
    setCards(fetchedCards);
  }, []);

  return (
    <div>
      <h1>Flash Cards</h1>
      {cards.length === 0 ? (
        <p>No cards yet. <Link to="/editor">Create your first card!</Link></p>
      ) : (
        <ul>
          {cards.map(card => (
            <li key={card.id}>
              <Link to={`/editor/${card.id}`}>
                {card.sideA.elements[0]?.content || 'Untitled Card'}
              </Link>
            </li>
          ))}
        </ul>
      )}
      <Link to="/editor">Create New Card</Link>
    </div>
  );
};

export default Home;----------------------------------------

File: ./src/pages/Editor.tsx
----------------------------------------
import React from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import CardEditor from '../components/cards/CardEditor';
import { Card } from '../types/Card';
import { getCard, saveCard } from '../services/storage';

const Editor: React.FC = () => {
  const { cardId } = useParams<{ cardId: string }>();
  const navigate = useNavigate();

  const card = cardId ? getCard(cardId) : undefined;

  const handleSave = (updatedCard: Card) => {
    saveCard(updatedCard);
    navigate('/');
  };

  return (
    <div>
      <h1>{cardId ? 'Edit Card' : 'Create New Card'}</h1>
      <CardEditor card={card} onSave={handleSave} />
    </div>
  );
};

export default Editor;----------------------------------------

File: ./src/pages/Editor.md
----------------------------------------
# Editor

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/pages/Home.md
----------------------------------------
# Home

## Purpose
The Home page serves as the main landing page for the application, displaying an overview of the user's decks and recent cards.

## Dependencies
- react
- @emotion/styled
- react-router-dom
- ../../components/decks/DeckList
- ../../components/cards/CardList
- ../../services/storage

## Main Functionality
1. Display a list of user's decks
2. Show recently created or studied cards
3. Provide quick access to create new decks or cards
4. Allow navigation to DeckManager and CardEditor

## TODO
- [x] Implement basic structure
- [x] Display list of cards
- [ ] Implement deck list display
- [ ] Add creation buttons for new decks and cards
- [ ] Implement recently studied cards section
- [ ] Style component using Emotion
- [ ] Add quick access to study mode
- [ ] Implement search functionality for decks and cards
- [ ] Write unit tests----------------------------------------

File: ./src/pages/__tests__/Home.test.tsx
----------------------------------------
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { BrowserRouter as Router } from 'react-router-dom';
import Home from '../Home';
import * as storage from '../../services/storage';

jest.mock('../../services/storage');

describe('Home component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders the title', async () => {
    (storage.getCards as jest.Mock).mockResolvedValue([]);
    render(<Router><Home /></Router>);
    await waitFor(() => {
      expect(screen.getByText('Your Flash Cards')).toBeInTheDocument();
    });
  });

  it('displays loading state', async () => {
    (storage.getCards as jest.Mock).mockImplementation(() => new Promise(resolve => setTimeout(() => resolve([]), 100)));
    render(<Router><Home /></Router>);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
    });
  });

  it('displays error message on fetch failure', async () => {
    (storage.getCards as jest.Mock).mockRejectedValue(new Error('Fetch failed'));
    render(<Router><Home /></Router>);
    await waitFor(() => {
      expect(screen.getByText('Failed to load cards. Please try again later.')).toBeInTheDocument();
    });
  });

  it('displays existing cards', async () => {
    const mockCards = [
      {
        id: '1',
        deckId: '',
        sideA: { elements: [{ id: '1', type: 'text', content: 'Question 1', style: {}, position: { x: 0, y: 0, width: 100, height: 100 } }] },
        sideB: { elements: [{ id: '2', type: 'text', content: 'Answer 1', style: {}, position: { x: 0, y: 0, width: 100, height: 100 } }] }
      }
    ];
    (storage.getCards as jest.Mock).mockResolvedValue(mockCards);

    render(<Router><Home /></Router>);
    
    await waitFor(() => {
      expect(screen.getByText('Question 1')).toBeInTheDocument();
    });
    
    expect(screen.getByText('Answer 1')).toBeInTheDocument();
  });
});----------------------------------------

File: ./src/pages/DeckManagement.md
----------------------------------------
# DeckManagement

## Purpose
[Briefly describe the purpose of this file/component]

## Dependencies
- [List any dependencies]

## Props (if applicable)
- [List props and their types]

## Main Functionality
[Describe the main functionality or responsibilities]

## TODO
- [ ] Implement basic structure
- [ ] Add necessary logic
- [ ] Write unit tests
----------------------------------------

File: ./src/services/storage.md
----------------------------------------
# useDeck

## Purpose
The useDeck hook manages deck-related operations and state, providing an interface for components to interact with deck data.

## Dependencies
- react
- ../services/storage
- ../types/Deck
- ../types/Card

## Functionality
1. Fetch and manage deck data
2. Provide CRUD operations for decks
3. Handle card management within decks
4. Manage deck selection state

## Hook Structure
```typescript
const useDeck = () => {
  // Deck state management
  // CRUD operations
  // Card management functions

  return {
    decks,
    selectedDeck,
    createDeck,
    updateDeck,
    deleteDeck,
    selectDeck,
    addCardToDeck,
    removeCardFromDeck,
    reorderCardsInDeck,
  };
};
```

## TODO
- [ ] Implement deck state management
- [ ] Create CRUD operations for decks
- [ ] Add card management functions
- [ ] Integrate with storage service
- [ ] Write unit tests----------------------------------------

File: ./src/services/api.md
----------------------------------------
# API Service

## Purpose
The API service handles all communications with external APIs, including potential future backend services.

## Dependencies
- axios
- ../types/Card
- ../types/Deck

## Main Functionality
1. Handle API requests for future backend integration
2. Manage authentication (if implemented in the future)
3. Provide interfaces for data synchronization

## Service Structure
```typescript
class ApiService {
  private axiosInstance: AxiosInstance;

  constructor();
  
  // Authentication methods (for future use)
  login(credentials: Credentials): Promise<User>;
  logout(): Promise<void>;

  // Data synchronization methods
  syncCards(cards: Card[]): Promise<Card[]>;
  syncDecks(decks: Deck[]): Promise<Deck[]>;

  // Other API methods as needed
}
```

## TODO
- [ ] Set up Axios instance
- [ ] Implement authentication methods (placeholder for now)
- [ ] Create data synchronization methods
- [ ] Add error handling and request/response interceptors
- [ ] Write unit tests
- [ ] Document API endpoints and expected responses----------------------------------------

File: ./src/services/storage.ts
----------------------------------------
import { Card } from '../types/Card';
import { Deck } from '../types/Deck';

const CARDS_KEY = 'flashcards_cards';
const DECKS_KEY = 'flashcards_decks';

export const saveCards = (cards: Card[]): void => {
  localStorage.setItem(CARDS_KEY, JSON.stringify(cards));
};

export const getCards = (): Card[] => {
  const cards = localStorage.getItem(CARDS_KEY);
  return cards ? JSON.parse(cards) : [];
};

export const saveCard = (card: Card): void => {
  const cards = getCards();
  const index = cards.findIndex(c => c.id === card.id);
  if (index !== -1) {
    cards[index] = card;
  } else {
    cards.push(card);
  }
  saveCards(cards);
};

export const getCard = (cardId: string): Card | undefined => {
  const cards = getCards();
  return cards.find(card => card.id === cardId);
};

export const saveDecks = (decks: Deck[]): void => {
  localStorage.setItem(DECKS_KEY, JSON.stringify(decks));
};

export const getDecks = (): Deck[] => {
  const decks = localStorage.getItem(DECKS_KEY);
  return decks ? JSON.parse(decks) : [];
};

export const saveDeck = (deck: Deck): void => {
  const decks = getDecks();
  const index = decks.findIndex(d => d.id === deck.id);
  if (index !== -1) {
    decks[index] = deck;
  } else {
    decks.push(deck);
  }
  saveDecks(decks);
};

export const getDeck = (deckId: string): Deck | undefined => {
  const decks = getDecks();
  return decks.find(deck => deck.id === deckId);
};
----------------------------------------

Summary:
Total lines of user-generated content: 2828
